- linux 서버 성능 이슈 시 체크해봐야할 사항들

1. uptime
 - uptime을 통해 현재 대기중인 프로세스가 얼마나 있는지를 나타나는 load average값을 확인
 - 출력 정보
 1) 현재시간
 2) 시스템 부팅 후 운용된 시간
 3) 현재 시스템에 로그인된 사용자 수(/var/run/utmp 참조)
 4) 1분, 5분, 15분 동안의 시스템 평균 부하율

2. dmesg | tail
 - 시스템 메세지를 확인할 수 있는 커맨드
 - 부팅시부터 시작해서 모든 커널메세지가 출력

3. vmstat
 - virtual memory stat
 - vmstat 1 로 1초마다 정보를 보여줌
 - 항목
  1) r : CUP에서 동작 중인 프로세스의 숫자. CPU 자원이 포화(saturation)가 발생하는지 확인할 때 사용하는 값. r 값이 CPU의 값보다 큰 경우 포화되었다고 해석
  2) free : free memory를 kb단위로 나타냄. free -m을 이용해 조금 더 편하게 확인
  3) si, so : swap-in과 swap-out에 대한 값. 0이 아니라면 현재 시스템에 메모리가 부족한것
  4) us, sy, id, wa, st : 모든 CPU의 평균적인 CPU time을 측정. 각각 user time, 커널에서 사용되는 system time, idle, wait I/O 그리고 stolen time순(stolen time은 hypervisor가 가상 CPU를 서비스 하는 동안 실제 CPU를 차지한 시간을 이야기함).

4. mpstat
 - mpstat -p ALL 1
 - sysstat 패키지 설치 필요
 - CUP time을 CUP 별로 측정. 이 방법을 통하면 각 CPU별로 불균형한 상태를 확인할 수 있는데, 한 CPU만 일하고 있는것은 application이 single thread로 동작한다는 이야기다.

5. pidstat
 - pidstat 1
 - pidstat은 process당 top명령을 수행하는것과 비슷하다. 다만 차이점은 스크린 전체에 표시하는것이 아니라 지속적으로 변화하는 상황을 띄워주기 떄문에 상황변화를 기록하기 좋다.

6. iostat
 - iostat -xz 1
 - block device(HDD, SSD, …)가 어떻게 동작하는지 이해하기 좋은 툴
 - /s, w/s rkB/s, wkB/s: read 요청과 write 요청, read kB/s, write kB/s를 나타낸다. 어떤 요청이 가장 많이 들어오는지 확인해볼 수 있는 중요한 지표다. 성능 문제는 생각보다 과도한 요청때문에 발생하는 경우도 있기 때문이다.
 - await: I/O처리 평균 시간을 밀리초로 표현한 값이다. application한테는 I/O요청을 queue하고 서비스를 받는데 걸리는 시간이기 때문에 application이 이 시간동안 대기하게 된다. 일반적인 장치의 요청 처리 시간보다 긴 경우에는 블럭장치 자체의 문제가 있거나 장치가 포화된 상태임을 알 수 있다.

7. free -m
 - 항목
  1) buffers: Block 장치 I/O의 buffer 캐시, 사용량
  2) cached: 파일 시스템에서 사용되는 page cache의 양
 - 위 값들이 0에 가까워 지면 안된다. 이는 곧 높은 Disk I/O가 발생하고 있음을 의미한다(iostat으로 확인 가능)
 - -/+ buffers/cache는 사용중인 메모리와 여유 메모리의 양을 나타낸다. 리눅스는 빠르게 다시 애플리케이션에 메모리가 할당될 수 있도록 캐시메모리를 사용한다. 따라서 캐시 메모리도 여유 메모리에 포함되어 보여야한다.

8. top
 - 시스템 전반적으로 값을 확인